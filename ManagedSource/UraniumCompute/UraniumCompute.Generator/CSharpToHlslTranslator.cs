using System.Text;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace UraniumCompute.Generator;

internal class CSharpToHlslTranslator
{
    private readonly IReadOnlyList<CompiledMethod> methods;
    private StringBuilder SB = new();

    internal CSharpToHlslTranslator(IReadOnlyList<CompiledMethod> methods)
    {
        this.methods = methods;
    }

    internal string GenerateHlslCode()
    {
        SB.Append("// <auto-generated/>\n");
        foreach (var method in methods)
        {
            SB.Append(
                "[numthreads(1, 1, 1)]\n" +
                $"{method.Declaration.ReturnType} " +
                $"{method.Name}" +
                $"({TranslateParameters(method.Declaration.ParameterList)})"
            );
            SB.Append(Translate(method.Body));
        }
        var result = SB.ToString();
        return result;
    }

    string TranslateParameters(ParameterListSyntax parameterList)
    {
        return "uint3 globalInvocationID : SV_DispatchThreadID";
    }

    #region StatementsRegion

    string Translate(StatementSyntax statement)
    {
        return statement switch
        {
            BlockSyntax block => Translate(block),
            ReturnStatementSyntax returnStatement => Translate(returnStatement),
            _ => throw new NotImplementedException($"{statement.Kind()} is not implemented")
        };
    }

    string Translate(BlockSyntax block)
    {
        var sb = new StringBuilder();
        sb.Append("{ ");
        foreach (var statement in block.Statements)
        {
            sb.Append($"{Translate(statement)} ");
        }

        sb.Append("} ");

        return sb.ToString();
    }

    string Translate(ReturnStatementSyntax statement)
    {
        return $"return {Translate(statement.Expression!)};";
    }

    #endregion

    #region ExpressionsRegion

    string Translate(ExpressionSyntax expression)
    {
        return expression switch
        {
            LiteralExpressionSyntax literalExpression => Translate(literalExpression),
            BinaryExpressionSyntax binaryExpression => Translate(binaryExpression),
            PostfixUnaryExpressionSyntax postfixUnaryExpression => Translate(postfixUnaryExpression),
            PrefixUnaryExpressionSyntax prefixUnaryExpression => Translate(prefixUnaryExpression),
            _ => throw new NotImplementedException($"{expression.Kind()} is not implemented")
        };
    }

    string Translate(LiteralExpressionSyntax expression)
    {
        return expression.ToString();
    }

    string Translate(BinaryExpressionSyntax expression)
    {
        return expression.Kind() switch
        {
            SyntaxKind.AddExpression =>
                $"({Translate(expression.Left)} + {Translate(expression.Left)})",
            SyntaxKind.SubtractExpression =>
                $"({Translate(expression.Left)} - {Translate(expression.Left)})",
            SyntaxKind.MultiplyExpression =>
                $"({Translate(expression.Left)} * {Translate(expression.Left)})",
            SyntaxKind.DivideExpression =>
                $"({Translate(expression.Left)} / {Translate(expression.Left)})",
            SyntaxKind.ModuloExpression =>
                $"({Translate(expression.Left)} % {Translate(expression.Left)})",
            SyntaxKind.LeftShiftExpression =>
                $"({Translate(expression.Left)} << {Translate(expression.Left)})",
            SyntaxKind.RightShiftExpression =>
                $"({Translate(expression.Left)} >> {Translate(expression.Left)})",
            SyntaxKind.LogicalOrExpression =>
                $"({Translate(expression.Left)} || {Translate(expression.Left)})",
            SyntaxKind.LogicalAndExpression =>
                $"({Translate(expression.Left)} && {Translate(expression.Left)})",
            SyntaxKind.BitwiseOrExpression =>
                $"({Translate(expression.Left)} | {Translate(expression.Left)})",
            SyntaxKind.BitwiseAndExpression =>
                $"({Translate(expression.Left)} & {Translate(expression.Left)})",
            SyntaxKind.ExclusiveOrExpression =>
                $"({Translate(expression.Left)} ^ {Translate(expression.Left)})",
            SyntaxKind.EqualsExpression =>
                $"({Translate(expression.Left)} = {Translate(expression.Left)})",
            SyntaxKind.NotEqualsExpression =>
                $"({Translate(expression.Left)} != {Translate(expression.Left)})",
            SyntaxKind.LessThanExpression =>
                $"({Translate(expression.Left)} < {Translate(expression.Left)})",
            SyntaxKind.LessThanOrEqualExpression =>
                $"({Translate(expression.Left)} <= {Translate(expression.Left)})",
            SyntaxKind.GreaterThanExpression =>
                $"({Translate(expression.Left)} > {Translate(expression.Left)})",
            SyntaxKind.GreaterThanOrEqualExpression =>
                $"({Translate(expression.Left)} >= {Translate(expression.Left)})",
            _ => throw new NotSupportedException($"{expression.Kind()} is not supported by HLSL")
        };
    }

    string Translate(PostfixUnaryExpressionSyntax expression)
    {
        return expression.Operand.Kind() switch
        {
            SyntaxKind.PostIncrementExpression => $"{expression.Operand}++",
            SyntaxKind.PostDecrementExpression => $"{expression.Operand}--",
            _ => throw new NotSupportedException($"{expression.Kind()} is not supported by HLSL")
        };
    }

    string Translate(PrefixUnaryExpressionSyntax expression)
    {
        return expression.Operand.Kind() switch
        {
            SyntaxKind.UnaryPlusExpression => $"+{expression.Operand}",
            SyntaxKind.UnaryMinusExpression => $"-{expression.Operand}",
            SyntaxKind.BitwiseNotExpression => $"~{expression.Operand}",
            SyntaxKind.LogicalNotExpression => $"!{expression.Operand}",
            SyntaxKind.PreIncrementExpression => $"++{expression.Operand}",
            SyntaxKind.PreDecrementExpression => $"--{expression.Operand}",
            _ => throw new NotSupportedException($"{expression.Kind()} is not supported by HLSL")
        };
    }

    #endregion
}
